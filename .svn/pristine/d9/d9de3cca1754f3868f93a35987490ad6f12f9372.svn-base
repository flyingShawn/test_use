package com.grampus.hualauncherkai.TcpSock;


import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;

import com.grampus.hualauncherkai.Data.GlobalPara;
import com.grampus.hualauncherkai.Data.NetDataHub;
import com.grampus.hualauncherkai.UI.MainActivity;
import com.grampus.hualauncherkai.Data.AndroidParameter;
import com.grampus.hualauncherkai.service.ScreenCastService;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import static com.grampus.hualauncherkai.util.DeviceInfoUtil.getPhoneIp;
import static com.grampus.hualauncherkai.util.DeviceInfoUtil.getWifiMacAddress;

public class CLogonSock extends Thread{


    //private Context context = null;

    private final String TAG = "TcpSocketClient";

    private Socket socket;
    private OutputStream outputStream;
    private InputStream inputStream;

    private BufferedOutputStream bufferedOutputStream;
    private Handler handler;
    private InetAddress remoteHost;
    private int remotePort;
    public int m_nEquipID = 0;
    public int m_nTimerCount = 0;

    private CPacket m_pack;
    private int m_nFlag = 0;
    public  String  m_szIP;
    public String   m_szMac;
    public String   m_szHostName;
    public CLogonSock(InetAddress remoteHost, int remotePort) {
        super( "CLogonSock");
        try {
            this.remoteHost = remoteHost;
            this.remotePort = remotePort;


            //String szTemp = "192.168.1.150";
            //String szTemp = "127.0.0.1";
            //this.remoteHost = InetAddress.getByName(szTemp);
            //this.remotePort = 6671;
        }
        catch(Exception e) {

        }
    }
    public String inet_ntoa(long raw) {
        /*
        return ((add & 0xff000000) >> 24) + "." + ((add & 0xff0000) >> 16)
                + "." + ((add & 0xff00) >> 8) + "." + ((add & 0xff));
                */
            byte[] b = new byte[] {(byte)(raw >> 24), (byte)(raw >> 16), (byte)(raw >> 8), (byte)raw};
            try {
                return InetAddress.getByAddress(b).getHostAddress();
            } catch(Exception e) {
                //No way here
                return null;
            }
    }
    public void OnReceiveCenterServPack(int nHeadCmd,long nReserved,ByteBuffer bodyBuf){

        //System.out.println("OnReceivePack------nHeadCmd:"+nHeadCmd);

        if(nHeadCmd == GlobalPara.WM_CLINET_LOGON_END){
            bodyBuf.position(0);
            m_nEquipID = bodyBuf.order(ByteOrder.LITTLE_ENDIAN).getInt( );//取四个字节，并将其转为int类型的数字
            m_pack.m_nUniqueID = m_nEquipID;
            NetDataHub.get().g_nEquipID = m_nEquipID;
            Log.i("OnReceivePack","------收到服务器定时器消息------WM_CLINET_LOGON_END.");
            NetDataHub.get().addLog("OnReceiveCenterServPack-----接收登陆成功----nEquipID:" + m_nEquipID + "---------WM_CLINET_LOGON_END.");
            //Log.i("OnReceiveCenterServPack","-----nEquipID:" + m_nEquipID + "---------WM_CLINET_LOGON_END.");
        }
        else if(nHeadCmd == GlobalPara.WM_ONLINE_TIMER){
            m_nTimerCount = 0;
            //Log.i("OnReceivePack","------收到服务器定时器消息------WM_ONLINE_TIMER.");
            NetDataHub.get().addLog("OnReceiveCenterServPack-----收到定时器消息--------WM_ONLINE_TIMER.");
        }
        else if(nHeadCmd == GlobalPara.SCREEN_BEGIN){

            try {
                boolean isMainThread = Looper.myLooper() == Looper.getMainLooper();
                Log.i("OnReceivePack","------收到服务器消息------SCREEN_BEGIN---isMainThread: "+isMainThread);

                String szManageIP = inet_ntoa(nReserved);
                AndroidParameter.serverIp = szManageIP;

                startService();
                Log.i("OnReceivePack","------收到服务器消息------SCREEN_BEGIN---end"+isMainThread);
                NetDataHub.get().addLog("OnReceiveCenterServPack-----接收开始屏幕监视消息--IP:"+szManageIP+"---SCREEN_BEGIN.");

            }catch (Exception e) {
                Log.e(TAG, "OnReceiveCenterServPack----error:"+e.toString() );
            }


        }

    }

    private void startService() {
        try{
            int stateResultCode = Activity.RESULT_OK;
            Intent stateResultData = NetDataHub.g_ResultData;
            Context contex = MainActivity.g_context;
            final Intent intent = new Intent(contex, ScreenCastService.class);

            if (stateResultCode != 0 && stateResultData != null) {
                //intent.putExtra(ExtraIntent.RESULT_CODE.toString(), stateResultCode);
                intent.putExtra("RESULT_DATA", stateResultData);

                //Log.i("OnReceivePack", "CLogonSock--stateResultCode:"+stateResultCode+" stateResultData.ts:"+ExtraIntent.RESULT_DATA.toString());
            }
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            contex.startService(intent);
        }catch (Exception e){
            Log.i("OnReceivePack","startService---: "+e.toString());
        }
    }
    private void WhileRecvDataTh(){
        System.out.println("WhileRecvDataTh----------begin  threadid:"+android.os.Process.myTid());

        int SOCK_MAX_PACKSIZE = 20*1024*1024;
        int nPackBodySize = 1024*100;
        ByteBuffer headBuf = ByteBuffer.allocate(100);
        ByteBuffer bodyBuf = ByteBuffer.allocate(nPackBodySize);

        boolean m_bPackHeadRevEnd = false;
        boolean m_bCurrentPackRevEnd = false;
        int m_nCurrentPackRevSize = 0;
        int m_dwCurrentPackBodySize = 0;
        int m_dwUnZipBodySize = 0;
        int m_nHeadCmd = 0;
        long m_nReserved = 0;



        try {

            //int nRead = inputStream.read(readBuf);
            //System.out.println("ReadBuf----------nRead:"+nRead);
            while (true) {
                int HeadLen = 17 * 4;
                if (!m_bPackHeadRevEnd) {
                    int nRec = inputStream.read(headBuf.array(), m_nCurrentPackRevSize, HeadLen - m_nCurrentPackRevSize);
                    if (nRec <= 0) {
                        System.out.println("WhileRecvDataTh------sock read header error.");
                        break;
                    } else {
                        m_nCurrentPackRevSize += nRec;
                        if (m_nCurrentPackRevSize == HeadLen)//包头接全了
                        {
                            m_bPackHeadRevEnd = true;
                            m_bCurrentPackRevEnd = false;
                            m_nCurrentPackRevSize = 0;

                            m_nHeadCmd = headBuf.order(ByteOrder.LITTLE_ENDIAN).getInt();

                            headBuf.position(8);
                            int nPackFlag = headBuf.order(ByteOrder.LITTLE_ENDIAN).getInt( );
                            //int nPackFlag = SockTransfer.int32Reverse(headBuf.getInt());
                            m_nReserved = headBuf.order(ByteOrder.BIG_ENDIAN).getInt( );

                            if (nPackFlag != GlobalPara.PACK_XFCenterServIDENTIFY) {
                                System.out.println("WhileRecvDataTh------packHead.nPackFlag != PACK_IDENTIFY error.");
                                close();
                                break;
                            }

                            headBuf.position(12*4);
                            //m_dwCurrentPackBodySize = SockTransfer.int32Reverse(headBuf.getInt());
                            m_dwCurrentPackBodySize = headBuf.order(ByteOrder.LITTLE_ENDIAN).getInt( )-HeadLen;

                            if (m_dwCurrentPackBodySize == (HeadLen) ) {
                                m_bPackHeadRevEnd = false;
                                m_bCurrentPackRevEnd = false;
                                m_nCurrentPackRevSize = 0;
                                bodyBuf.rewind();
                                headBuf.rewind();

                                OnReceiveCenterServPack(m_nHeadCmd,m_nReserved,bodyBuf);
                                continue;
                            }


                            if (m_dwCurrentPackBodySize > SOCK_MAX_PACKSIZE) {
                                System.out.println("WhileRecvDataTh------pack too large error.");
                                break;
                            }
                            else if (m_dwCurrentPackBodySize > nPackBodySize) {
                                bodyBuf = ByteBuffer.allocate(m_dwCurrentPackBodySize);
                                nPackBodySize = m_dwCurrentPackBodySize;
                            }
                        }
                    }
                } else if (!m_bCurrentPackRevEnd) {
                    int nRec = inputStream.read(bodyBuf.array(), m_nCurrentPackRevSize, m_dwCurrentPackBodySize - m_nCurrentPackRevSize);
                    if (nRec <= 0) {
                        System.out.println("WhileRecvDataTh------sock read body error.");
                        break;
                    } else {
                        //WriteLogEx(_T("RecvDataTh--Body----m_hsock:%d---接包身 nRec:%d"),nRec,m_hsock);

                        m_nCurrentPackRevSize += nRec;
                        if (m_nCurrentPackRevSize == m_dwCurrentPackBodySize)//接全包身
                        {
                            //WriteLogEx(_T("RecvDataTh--Body----nRec:%d---m_hsock:%d---包身接成功"),nRec,m_hsock);

                            m_bPackHeadRevEnd = false;
                            m_bCurrentPackRevEnd = false;
                            m_nCurrentPackRevSize = 0;

                            OnReceiveCenterServPack(m_nHeadCmd,m_nReserved,bodyBuf);

                            bodyBuf.rewind();
                            headBuf.rewind();
                        }
                    }
                }
            }
        }
        catch(IOException e){
            NetDataHub.get().addLog("WhileRecvDataTh-------异常出错:"+e.toString());
            e.printStackTrace();
            //close();
        }
        close();
    }

    void BeginConnectAndRecvTh(){

        try {

            NetDataHub.get().addLog("BeginConnectAndRecvTh------Connect XFServer---Begin:"+remoteHost.toString());

            socket = new Socket();
            SocketAddress socAddress = new InetSocketAddress(remoteHost, remotePort);
            socket.connect(socAddress, 3000);
            //socket = new Socket(remoteHost, remotePort);
            outputStream = socket.getOutputStream();
            inputStream = socket.getInputStream();
            //bufferedOutputStream = new BufferedOutputStream(outputStream);//del by gwb;感觉没有必要用这个。用了BufferedOutputStream还得flush数据才真实发。

            if(m_pack == null) {
                m_pack = new CPacket();
            }


            String szIP = getPhoneIp();//"192.168.1.150";
            String szMac = getWifiMacAddress();//"48:2c:a0:ce:f2:ea";
            String szHostName =   android.os.Build.BRAND+"-" +android.os.Build.MODEL;// 手机品牌+手机型号

            if(m_pack.SendLogonToCenterServ(outputStream,szIP,szMac,szHostName) == false)
            {

            }
            NetDataHub.get().addLog("BeginConnectAndRecvTh------连接中心服务器成功. szIP:"+szIP+"  Mac:"+szMac + "  HostName:"+szHostName);
            //m_pack.SendCmdToCenterServ(outputStream,GlobalPara.WM_ONLINE_TIMER);
            System.out.println("tcp----------begin  threadid:"+android.os.Process.myTid());

            new Thread(new Runnable() { // 匿名类的Runnable接口
                @Override
                public void run() {
                    WhileRecvDataTh();
                }
            }).start();
        } catch (Exception e) {
            NetDataHub.get().addLog("BeginConnectAndRecvTh------catch Error:"+e.toString());
            Log.e(TAG, "Socket creation failed - " + e.toString());
            socket = null;
            outputStream = null;
            bufferedOutputStream = null;
        }
    }
    @Override
    public void run() {
        try {
            BeginConnectAndRecvTh();

            Looper.prepare();
            handler = new Handler() {       //080300  002 Handler的创建
                @Override
                public void handleMessage(Message message) {
                    if(message == null || message.obj == null) return;
                    byte[] msg = (byte[])message.obj;
                    try {
                        if(socket != null) {

                            System.out.println("handleMessage----------发送字节数为:" + msg.length + "线程ID:" + android.os.Process.myTid());
                        }
                        //sleep(15000);
                    } catch (Exception e) {
                        e.printStackTrace();
                        close();
                    }
                }
            };
            Looper.loop();

        } catch (Exception e) {
            Log.e(TAG, "Socket creation failed - " + e.toString());
            socket = null;
            outputStream = null;
            bufferedOutputStream = null;
        }
    }

    public void close() {
        if (socket != null) {
            try {
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                socket = null;
                outputStream = null;
                bufferedOutputStream = null;
            }
        }
    }
    public void SendTimerCmdToServ()
    {
        boolean bOK = false;
        try {
            if(handler == null || socket == null || outputStream == null) {
                NetDataHub.get().addLog("SendTimerCmdToServ------连接存在异常！！！");
            }
            else
            {
                NetDataHub.get().addLog("SendTimerCmdToServ---------发送定时器到XFServer.");
                //System.out.println("SendTimerCmdToServ---------发送定时器到XFServer.");
                m_pack.SendCmdToCenterServ(outputStream, GlobalPara.WM_ONLINE_TIMER);
                bOK = true;
            }
        } catch (Exception e) {
            NetDataHub.get().addLog("SendTimerCmdToServ------catch Error!");
            e.printStackTrace();
        }

        if(!bOK) {
            close();
            NetDataHub.get().addLog("SendTimerCmdToServ------发送失败，开始重连服务器.");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
            }
            BeginConnectAndRecvTh();
        }
    }
    public void send(final byte[] data) {       ///080300 03 send ,   handle对象发送message和传递runnable对象
        if(handler == null || socket == null || outputStream == null)  {
            return;
        }

        try {


            try {
                //String path = "/data/data/com.github.magicsih.androidscreencaster/tel-after2.h264";//080300fsy H264

                if(data.length>0  ) {

                    Message message = handler.obtainMessage();
                    message.obj = data;
                    handler.sendMessage(message);
                }


            } catch (Exception e) {
                e.printStackTrace();
            }
            //----------------end.



            //System.out.println("send----消息之后结束-------调用发送:" + data.length + "线程ID:" + android.os.Process.myTid());
        }
        catch(Exception e){
            e.printStackTrace();
        }
    }
}
