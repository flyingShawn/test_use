package com.grampus.hualauncherkai.service;

import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.GestureDescription;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.BitmapFactory;
import android.graphics.Path;
import android.os.Build;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;

import androidx.annotation.RequiresApi;
import androidx.core.app.NotificationCompat;

import com.grampus.hualauncherkai.Data.AndroidParameter;
import com.grampus.hualauncherkai.Data.AndroidPolicy;
import com.grampus.hualauncherkai.Data.NetDataHub;
import com.grampus.hualauncherkai.FloatWindow.EMMFloatWindowService;
import com.grampus.hualauncherkai.Receiver.WifiHub;
import com.grampus.hualauncherkai.Tools.Save;
import com.grampus.hualauncherkai.UI.MainActivity;

import java.util.List;

import static com.grampus.hualauncherkai.R.mipmap.ic_launcher;
import static com.grampus.hualauncherkai.Receiver.WifiHub.g_isWhiteWifi;
import static com.grampus.hualauncherkai.UI.MainActivity.g_bUseHuaWeiMDM;
import static com.grampus.hualauncherkai.UI.MainActivity.g_isApplyForFloat;

/**
 * 这个服务属于系统级别辅助服务 需要在设置里去手动开启 和平常app里
 * 经常使用的service 是有很大不同的 非常特殊
 * add by fsy 2021.8.8
 */
@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
public class EMMAccessibilityService extends AccessibilityService {
    public EMMAccessibilityService() {
    }

    private static EMMAccessibilityService mService;

    public static synchronized EMMAccessibilityService getInstance(){
        if(mService == null){
            mService = new EMMAccessibilityService();
        }
        return mService;
    }

    private final String TAG = "EMMA11yService";
    private void setForeground() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                NotificationChannel channel = new NotificationChannel("Foreground_Service",
                        "Foreground_Service", NotificationManager.IMPORTANCE_LOW);
                NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
                if (manager == null) {
                    return;
                }
                manager.createNotificationChannel(channel);
                Notification notification =
                        new NotificationCompat.Builder(this, "Foreground_Service")
                                .setContentTitle("阳途安卓辅助功能")
                                .setContentText("正在运行中")
                                .setWhen(System.currentTimeMillis())
                                .setSmallIcon(ic_launcher)
                                .setLargeIcon(BitmapFactory.decodeResource(getResources(), ic_launcher))
                                .build();
                startForeground(11, notification);
            }
        }catch (Exception e) {
            Log.e(TAG, "setForeground------error:"+e.toString() );
        }
    }

    private void readNACAndConnect() {

        //测试 在服务中 读取文件中的策略      //测试无问题
        Object NACAddrObj = Save.readFile(this, "NACAddr");  //add by fsy 2021.12.20
        if(NACAddrObj != null)
        {
            AndroidPolicy.NACAddr0 = (String) NACAddrObj;
            Log.w(TAG, "==NACAddr0 = "+AndroidPolicy.NACAddr0);
        }


        new Thread(new Runnable() { // 匿名类的Runnable接口
            @Override
            public void run() {
                String rs = AndroidPolicy.getNACCheck();
                NetDataHub.get().addLog("EMMA11yService-----准入访问返回结果:【"+rs+"】");
            }
        }).start();


    }
    public void openMainActivity () {
        Intent intent = new Intent(this, MainActivity.class);
//      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_NEW_TASK);
  //      startActivity(intent);
    }

    /**
     * AccessibilityService 这个服务可以关联很多属性，这些属性 一般可以通过代码在这个方法里进行设置，
     * 如果很复杂比如需要初始化广播之类的工作 都可以在这个方法里写。
     */
    @Override
    protected void onServiceConnected() {
        super.onServiceConnected();
        Log.w(TAG, "MyAccessubility---onServiceConnected---- " );
        setForeground();
        mService = this;
    //  openMainActivity();
        readNACAndConnect();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.w(TAG, "MyAccessubility---onStartCommand---- " );
        return super.onStartCommand(intent, flags, startId);
    }

    public static boolean isStart() {
        return mService != null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i(TAG, "MyAccessubility---onCreate--");
    }
    @Override
    public void onInterrupt() {
        Log.i(TAG, "MyAccessubility---onInterrupt--" );
    }

    @Override
    public boolean onUnbind(Intent intent) {
        Log.w(TAG, "MyAccessibilityService--------onUnbind -- ");
        mService = null;
        try{
            stopForeground(true);
        }catch (Exception e){
            Log.i(TAG, "setForeground--error "+e.toString());
        }

        return super.onUnbind(intent);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.i(TAG, "MyAccessibilityService------onDestroy ------ ");
        mService = null;
        try{
            stopForeground(true);
        }catch (Exception e){
            Log.i(TAG, "setForeground--error "+e.toString());
        }


    }

    /**
     * 当你这个服务正常开启的时候，就可以监听事件了，当然监听什么事件，监听到什么程度 都是由给这个服务的属性来决定的，
     * 监控时不需要用这个监听，我会主动发起调用
     */
    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {

        try{
     //       Log.d(TAG,"event.getEvent---- "+event.getPackageName()+"|"+Integer.toHexString(event.getEventType()));//打印一下类型

            /*
            if (event == null ||event.getPackageName()==null|| !event.getPackageName().toString().contains("packageinstaller"))//不写完整包名，是因为某些手机(如小米)安装器包名是自定义的
                return;
          if(!g_bUseHuaWeiMDM)   //Test 测试用，相当于直接返回
            {
                return;
            }
*/

            switch (event.getEventType()) {


                case AccessibilityEvent.TYPE_WINDOWS_CHANGED://TYPE_VIEW_CLICKED  //typeAllMask



                    if(g_bUseHuaWeiMDM)
                    {
                        Log.i(TAG, "华为==================== ");
                        return;
                    }

                    if(NetDataHub.get() != null){

                        if(!NetDataHub.get().isProtectSetting())
                            return;
                        if(NetDataHub.get().isCtrlApp()||NetDataHub.get().isCtrlWifi()) {

                            new Thread(new Runnable() { // 匿名类的Runnable接口
                                @Override
                                public void run() {
                                    AccessibilityNodeInfo rowNode1 = getRootInActiveWindow();
                                    if (rowNode1 == null) {
                                        Log.i(TAG, "windowList is　null");
                                        return;
                                    } else {
                                        int i=0;
                                        while (forbidSystemUI(rowNode1)) {
                                            if(i++>100)		//防止循环太多次出故障 100
                                            {
                                                break;
                                            }
                                            rowNode1 = getRootInActiveWindow();
                                            try {
                                                Thread.sleep(20);
                                            } catch (InterruptedException e) {
                                                Log.e(TAG, "TYPE_WINDOWS_CHANGED error---"+e.toString());
                                            }
                                        }
                                    }
                                }
                            }).start();
                        }
                    }
            }
        }catch (Exception e){
            Log.e(TAG, "onAccessibilityEvent error---"+e.toString());
        }
    }

    public boolean recycleFindSetting(AccessibilityNodeInfo info){

        if(info.getPackageName()!=null&&info.getPackageName().equals("com.android.settings")) {
            if(info.getText()!=null)
            {
                //Log.i(TAG, "Text：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName()+"|D:"+info.getContentDescription());
                //NetDataHub.get().addLog("Text：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName()+"|D:"+info.getContentDescription());
                    //测试四台不同品牌设备，WIFI界面内部是title
                if(WifiHub.wifiSsid.equals(info.getText())) {
                    if(("android:id/title").equals(info.getViewIdResourceName())){
                        Log.i(TAG, "recycleFindSetting-----find wifiSsid");
                        if(EMMFloatWindowService.isStart())  //服务已经开启了
                            EMMFloatWindowService.getInstance().isShow = false;// 发现设置wifi界面，不要弹窗
                        return true;  //如果再子窗口找到了wifi名，不处理，如果遍历完都没有，则响应返回；
                    }else
                    {
                        //要全体退出
                        performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
                         return false;
                    }
                }
                if("显示在其他应用的上层".equals(info.getText())) {
                    return true;    //悬浮框权限申请界面，不执行返回
                }
            }
        }

        for (int i = 0; i < info.getChildCount(); i++) {
            if(info.getChild(i)!=null){
                if(recycleFindSetting(info.getChild(i)))
                    return true;
            }
        }
        return false;
    }

    /**
     * 首先判断包名时systemui和settings相关才会进入
     * 下拉界面以wifi_combo辨认
     * 非白名单下的wifi界面以当前wifi名+android:id/title辨认
     * @param info
     * @return
     */
    public boolean forbidSystemUI(AccessibilityNodeInfo info){
        try{
            //Log.i(TAG, "fText：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName()+"|P:"+info.getPackageName());
            //Text：null|android.widget.FrameLayout|null|P:com.grampus.hualauncherkai

           // Log.i(TAG, "Description：" + info.getContentDescription()+"|"+info.getPackageName());
           // NetDataHub.get().addLog("Text：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName()+"|D:"+info.getContentDescription()+"|"+info.getPackageName());
            if (info.getPackageName()!=null)
            {
                if (info.getPackageName().equals("com.android.systemui")) {

                    if(info.getViewIdResourceName()!=null&&info.getViewIdResourceName().equals("com.android.systemui:id/wifi_combo")){
                        Log.w(TAG, " forbidUI" );
                        performGlobalAction(AccessibilityService.GLOBAL_ACTION_HOME);
                        return true;
                    }

                    for (int i = 0; i < info.getChildCount(); i++) {
                        if(info.getChild(i)!=null){
                            if(forbidSystemUI(info.getChild(i)))
                                return true;
                        }
                    }
                }
                else if (info.getPackageName().equals("com.android.settings")) {   //找到wifi设置界面则返回false
                    if(!g_isWhiteWifi||g_isApplyForFloat) {          //非白名单  或者是申请悬浮请求
                        if(info.getText()!=null) {   //Log.i(TAG, "Text：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName()+"|D:"+info.getContentDescription());
                            //NetDataHub.get().addLog("Text：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName()+"|D:"+info.getContentDescription());
                            //测试四台不同品牌设备，WIFI界面内部是title
                            if(WifiHub.wifiSsid.equals(info.getText())) {
                                if(("android:id/title").equals(info.getViewIdResourceName())){
                                    Log.w(TAG, "forbidSystemUI-----find wifiSsid");
                                    NetDataHub.get().addLog("wifi设置界面-----不返回 ");
                                    if(EMMFloatWindowService.isStart())  //服务已经开启了
                                        EMMFloatWindowService.getInstance().isShow = false;// 发现设置wifi界面，不要弹窗
                                    return false;  //如果再子窗口找到了wifi名，不处理，如果遍历完都没有，则响应返回；
                                }else {
                                    //要全体退出
                                   // Log.w(TAG, "---直接返回--");
                                    //部分横屏过宽，可以左侧选项，右侧设置，左右侧设置不同，以后再考虑
                                    performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
                                    return false;
                                }
                            }
                            if("显示在其他应用的上层".equals(info.getText())) {
                                return false;    //悬浮框权限申请界面，不执行返回
                            }
                        }   //未找到，继续遍历子窗口，无子窗口则返回true;
                        for (int i = 0; i < info.getChildCount(); i++) {
                            if(info.getChild(i)!=null){
                                if(!forbidSystemUI(info.getChild(i)))
                                    return false;
                            }
                        }
                        return true;
                    }
                    Log.w(TAG, "forbidSystemUI----- forbidsetting");
                    performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
                    return true;
                }
            }

        }catch (Exception e){
            Log.e(TAG, "forbidSystemUI error---"+e.toString());
        }
        return false;
    }
/*Test 针对截屏窗口同意的，现在不需要
    public void recycleFind(AccessibilityNodeInfo info) {

        try{
            if (info.getChildCount() == 0) {

                //Log.i(TAG, "showDialog:" + info.canOpenPopup());
                //Log.i(TAG, "Text：" + info.getText());
                Log.i(TAG, "Text：" + info.getText()+"|"+info.getClassName()+"|"+info.getViewIdResourceName());
                if("立即开始".equals(info.getText()))
                {
                    if (info.isClickable()) {
                        Log.i(TAG, "clickView-----------------");//类型都列出来了
                        info.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                        isAutoAgree = false;

                        return; //找到之后直接Return   小概率事件撞到别的控件
                    }
                }
            } else {
                for (int i = 0; i < info.getChildCount(); i++) {
                    if(info.getChild(i)!=null){
                        recycleFind(info.getChild(i));
                    }
                }
            }
        }catch (Exception e){
            Log.i(TAG, "recycle error---"+e.toString());
        }
    }

 */
    /**
     * 滑动轨迹
     * 注意7.0以上的手机才有此方法，请确保运行在7.0手机上
     * 2021.11.13 更新滑动时间由管理机传递过来
     */
    public void dispatchGesture(int x, int y,int xPos, int yPos,int nTime) {
        try {
            Path path = new Path();
            path.moveTo(x , y);
            if(xPos<15)
                xPos = 15;

            if(nTime<50)
            {
                nTime = 50;
            }
            //约束一下X,Y的范围，未知名情况下会为负，消除此影响
            xPos = xPos > 15 ? xPos:15;
            int xMax = (int)(AndroidParameter.width * AndroidParameter.density)-15;
            xPos = xPos < xMax? xPos:xMax;

            yPos = yPos > 15 ? yPos:15;
            int yMax = (int)(AndroidParameter.hight * AndroidParameter.density)-15;
            yPos = yPos < yMax? yPos:yMax;

            path.lineTo(xPos, yPos);

         //   Log.w("OnReceivePack", "左击弹起：" + x + "," + y + "," + xPos + "," + yPos);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {

                dispatchGesture(new GestureDescription.Builder().addStroke(new GestureDescription.StrokeDescription
                       (path, 0, nTime)).build(), null, null);
          }
//        new AccessibilityService.GestureResultCallback(){
//            @Override
//            public void onCompleted(GestureDescription gestureDescription) {
//                super.onCompleted(gestureDescription);
//            }
//
//            @Override
//            public void onCancelled(GestureDescription gestureDescription) {
//                super.onCancelled(gestureDescription);
//            }
//        }

        }catch (Exception e) {
            Log.e(TAG, "dispatchGesture-----error:"+e.toString() );
        }
    }

    /**
     * 长按指定位置
     * 注意7.0以上的手机才有此方法，请确保运行在7.0手机上
     */
    public void dispatchGestureLongClick(int x, int y) {
        try {

            Path path = new Path();
            path.moveTo(x - 1, y - 1);
            path.lineTo(x, y - 1);
            path.lineTo(x, y);
            path.lineTo(x - 1, y);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                dispatchGesture(new GestureDescription.Builder().addStroke(new GestureDescription.StrokeDescription
                        (path, 0, 800)).build(), null, null);
            }
        }catch (Exception e) {
            Log.e(TAG, "dispatchGestureLongClick-------- "+e.toString() );
        }
    }


    public boolean rycleFindClick(String text){
        try {
            for (int i = 0; i <10 ; i++) {
                if(findTextClick(getRootInActiveWindow(),text))
                    break;
                if(i==9) {
                    Log.w(TAG, "查找------" + text + "------ 失败");
                    return false;
                }
                Thread.sleep(200);
            }

            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            return false;
        }
    }
    public void autoUpdate() {

        // AccessibilityNodeInfo nodeInfo = getRootInActiveWindow(); //当前窗口根节点
        try
        {
            Thread.sleep(2000);
            rycleFindClick("安装");

            Thread.sleep(2000);
            rycleFindClick("允许");

            Thread.sleep(2000);
            rycleFindClick("继续安装");

            Thread.sleep(2000);
            rycleFindClick("安装");
            Thread.sleep(1000);
            rycleFindClick("由系统确定");

            rycleFindClick("打开");
        }catch (Exception e){

        }

    }


    //手动写的代码循环查找子节点，不用了，用系统方法findAccessibilityNodeInfosByText吧
    public boolean autoUpdate1() {

        try {

            Thread.sleep(2000);

            for (int i = 0; i <8 ; i++) {
                if(findKey(getRootInActiveWindow(), "安装"))
                    break;
                if(i==7)
                    Log.w(TAG,"安装----- 失败");
                Thread.sleep(500);
            }



            Thread.sleep(2000);
            for (int i = 0; i <5 ; i++) {
                if(findKey(getRootInActiveWindow(), "允许"))
                    break;
                if(i==4)
                    Log.w(TAG,"允许----- 失败");
                Thread.sleep(300);
            }


            Thread.sleep(2000);
            for (int i = 0; i <20 ; i++) {
                if(findKey(getRootInActiveWindow(), "继续安装","安装"))
                    break;
                if(i==19)
                    Log.w(TAG,"继续安装----- 失败");
                Thread.sleep(300);
            }


            Thread.sleep(1000);
            for (int i = 0; i <5 ; i++) {
                if(findKey(getRootInActiveWindow(), "由系统确定"))   //淮二PDA的存储位置
                    break;
                if(i==4)
                    Log.w(TAG,"由系统确定----- 失败");
                Thread.sleep(300);
            }

        } catch (Exception e) {
            Log.e(TAG,"autoUpdate----- error"+e.toString());
        }finally {
            Log.w(TAG,"autoUpdate----- end");
            return true;
        }
    }

    public void  agreeScreenCast() {

        try{
            if(rycleFindClick("立即开始")){
                Thread.sleep(1800);
                rycleFindClick("立即开始");
            }
 /*
            for (int i = 0; i <10 ; i++) {
                if(findKey(getRootInActiveWindow(),"立即开始"))
                    break;
                if(i==9)
                    Log.w(TAG,"获取截屏权限----- 失败");
                Thread.sleep(100);
            }
 */
        } catch (Exception e) {
            Log.e(TAG,"agreeScreenCast----- error"+e.toString());
        }finally {
            Log.w(TAG,"agreeScreenCast----- end");
        }
    }


    public boolean findKey(AccessibilityNodeInfo info,String... text) {

        if(info==null)
        {
            Log.d(TAG,"(info==null)"+text);
            return false;
        }

        Log.i(TAG, "findKeyText："+ text+"|"+ info.getText()+"|"+info.getClassName()+"|P:"+info.getPackageName());

        for(String temp:text)
        {
            if(temp.equals(info.getText()))
            {
                Log.w(TAG,"findKey --成功-- "+temp);
                info.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                return true;
            }
        }
        for (int i = 0; i < info.getChildCount(); i++) {
         if(findKey(info.getChild(i),text))
            return true;
        }
        return false;
    }

    private boolean findTextClick(AccessibilityNodeInfo nodeInfo, String text) {

        try {
            if (nodeInfo == null)
                return false;
            List<AccessibilityNodeInfo> nodes = nodeInfo.findAccessibilityNodeInfosByText(text);

            Log.i(TAG, "findTextClick: " + text + ", "  + " ViewIdResourceName:"+nodeInfo.getViewIdResourceName());
            if (nodes == null || nodes.isEmpty())
                return false;
            Log.i(TAG, "findTextClick: " + text + ", " + nodes.size() + ", ");
            for (AccessibilityNodeInfo node : nodes) {
                if (node.isEnabled() && node.isClickable()) {
                    node.performAction(AccessibilityNodeInfo.ACTION_CLICK);

                    node.getPackageName().equals(getPackageName());
                    Log.i(TAG, "Text：" + node.getText()+"|"+"|"+node.getViewIdResourceName()+"|P:"+node.getPackageName()+"|:"+node.getPackageName());
                    return true;
                }
            }
        }catch (Exception e)
        {
            Log.e(TAG,"findTxtClick---"+text+"---error:"+e.toString());
        }
        return false;
    }

    private boolean findEMMClick(AccessibilityNodeInfo nodeInfo, String text) {

        try {

            Log.i(TAG, "findEMMClick: " + text );
            if (nodeInfo == null)
                return false;
            List<AccessibilityNodeInfo> nodes = nodeInfo.findAccessibilityNodeInfosByText(text);

            if (nodes == null || nodes.isEmpty())
                return false;
            Log.i(TAG, "findEMMClick: " + text + ", " + nodes.size());
            for (AccessibilityNodeInfo node : nodes) {

                Log.i(TAG, "nodes: " + nodes );
                Log.i(TAG, "Text：" + node.getText()+"|"+"|"+node.getViewIdResourceName()+"|P:"+node.getPackageName()+"|:"+ getPackageName());
                if (node.isEnabled() && node.isClickable() && getPackageName().equals(node.getPackageName())){
                    node.performAction(AccessibilityNodeInfo.ACTION_CLICK);

                    Log.i(TAG, "isEnabled  isClickable" );
                    return true;
                }
            }
        }catch (Exception e)
        {
            Log.e(TAG,"findTxtClick---"+text+"---error:"+e.toString());
        }
        return false;
    }

    /**
    * @author  fsy
    * @date    2022/1/7 9:17
    * @return
    * @description  自动同意开启悬浮框，不好用
    */
    public void autoAgree() {

        try
        {
            Log.i(TAG, "autoAgree: EMM 悬浮框1");

            AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
            if (nodeInfo == null)
                return  ;

            rycleFindClick("EMM");
            Log.i(TAG, "autoAgree: EMM 悬浮框2");
            rycleFindClick("允许显示在其他应用上层");

            Log.i(TAG, "autoAgree: EMM" + ", "  + " ViewIdResourceName:"+nodeInfo.getViewIdResourceName());

        }catch (Exception e){

        }
    }
}